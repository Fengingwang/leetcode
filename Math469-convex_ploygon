

题目大意： 给定一组点，顺序相连可以组成一个多边形。判断多边形是否是凸包。
注意：
最少3个，最多10000个点
坐标在-10,000 到 10,000之间。
你可以假设组成的多边形总是简单多边形。换言之，我们确保每个顶点都是两条边的交点，其他边不会相互交叉。

解题思路：
这道题让我们让我们判断一个多边形是否为凸多边形，关于凸多边形的性质，忘了的去面壁。
就是所有的顶点角都不大于180度。
那么我们该如何快速验证这一个特点呢，计算的curve的法向量是非常重要的手段，
一段连续曲线可以离散看成许多离散点组成，而相邻的三个点就是最基本的单位，我们可以算由三个点组成的一小段曲线的法线方向，
而凸多边形的每个三个相邻点的法向量方向都应该相同，要么同正，要么同负。
那么我们只要遍历每个点，然后取出其周围的两个点计算法线方向，然后跟之前的方向对比，如果不一样，直接返回false。
这里我们要特别注意法向量为0的情况，
如果某一个点的法向量算出来为0，那么正确的pre就会被覆盖为0，后面再遇到相反的法向就无法检测出来，
所以我们对计算出来法向量为0的情况直接跳过即可，
So 遍历顶点，判断相邻三个顶点A、B、C组成的两个向量(AB, AC)的叉积是否同负同正。

class Solution(object):
    def isConvex(self, points):
        """
        :type points: List[List[int]]
        :rtype: bool
        """
        def crossProduct(p0, p1, p2):
            x0, y0 = p0
            x1, y1 = p1
            x2, y2 = p2
            return (x2 - x0) * (y1 - y0) - (x1 - x0) * (y2 - y0)
        size = len(points)
        last = 0
        for x in range(size):
            p0, p1, p2 = points[x], points[(x + 1) % size], points[(x + 2) % size]
            p = crossProduct(p0, p1, p2)
            if p * last < 0:
                return False
            last = p
        return True
