# Time:  O(n)
# Space: O(1)
# Given an integer array of size n,
# find all elements that appear more than [n/3] times.
# The algorithm should run in linear time and in O(1) space.

# Moore Voting
# 观察可知，数组中至多可能会有2个出现次数超过 ⌊ n/3 ⌋ 的众数
# 记变量n1, n2为候选众数； c1, c2为它们对应的出现次数
# 遍历数组，记当前数字为num
# 若num与n1或n2相同，则将其对应的出现次数加1
# 否则，若c1或c2为0，则将其置为1，对应的候选众数置为num
# 否则，将c1与c2分别减1
# 最后，再统计一次候选众数在数组中出现的次数，若满足要求，则返回之。

class Solution:
    # @param {integer[]} nums
    # @return {integer[]}
    def majorityElement(self, nums):
        n1 = n2 = None
        c1 = c2 = 0
        for num in nums:
            if n1 == num:
                c1 += 1
            elif n2 == num:
                c2 += 1
            elif c1 == 0:
                n1, c1 = num, 1
            elif c2 == 0:
                n2, c2 = num, 1
            else:
                c1, c2 = c1 - 1, c2 - 1
        size = len(nums)
        return [n for n in (n1, n2) if n is not None and nums.count(n) > size / 3]

# 求众数问题: 有很多种解法，其中我感觉比较好的有两种，
# 一种是用哈希表，这种方法需要O(n)的时间和空间，
# 另一种是用一种叫摩尔投票法 Moore Voting，需要O(n)的时间和O(1)的空间，
# 这种投票法先将第一个数字假设为众数，然后把计数器设为1，比较下一个数和此数是否相等，若相等则计数器加一，反之减一。
# 然后看此时计数器的值，若为零，则将当前值设为候选众数。
# 以此类推直到遍历完整个数组，当前候选众数即为该数组的众数。
# 首先要明确的是这个叼炸天的方法是有前提的，就是数组中一定要有众数的存在才能使用，
# 下面我们来看本算法的思路，这是一种先假设候选者，然后再进行验证的算法。
# 我们现将数组中的第一个数假设为众数，然后进行统计其出现的次数，如果遇到同样的数，则计数器自增1，否则计数器自减1，如果计数器减到了0，则更换当前数字为候选者。
# 这是本算法的精髓所在，为啥遇到不同的要计数器减1呢，为啥减到0了又要更换候选者呢？
# 首先是有那个强大的前提存在，一定会有一个出现超过半数的数字存在，那么如果计数器减到0了话，
# 说明目前不是候选者数字的个数已经跟候选者的出现个数相同了，那么这个候选者已经很weak，不一定能出现超过半数，我们选择更换当前的候选者。
# 那有可能你会有疑问，那万一后面又大量的出现了之前的候选者怎么办，不需要担心，如果之前的候选者在后面大量出现的话，其又会重新变为候选者，直到最终验证成为正确的众数

# 算法的基本思想
# 每次都找出一对不同的元素，从数组中删掉，直到数组为空或只有一种元素。 不难证明，如果存在元素e出现频率超过半数，那么数组中最后剩下的就只有e。
# 当然，最后剩下的元素也可能并没有出现半数以上。比如说数组是[1, 2, 3]，最后剩下的3显然只出现了1次，并不到半数。
# 排除这种false positive情况的方法也很简单，只要保存下原始数组，最后扫描一遍验证一下就可以了。

# 算法的实现
# 在算法执行过程中，我们使用常量空间实时记录一个候选元素c以及其出现次数f(c)，c即为当前阶段出现次数超过半数的元素。
# 在遍历开始之前，该元素c为空，f(c)=0。
# 然后在遍历数组A时，如果f(c)为0，表示当前并没有候选元素，也就是说之前的遍历过程中并没有找到超过半数的元素。
# 那么，如果超过半数的元素c存在，那么c在剩下的子数组中，出现次数也一定超过半数。
# 因此我们可以将原始问题转化为它的子问题。此时c赋值为当前元素, 同时f(c)=1。

# 如果当前元素A[i] == c, 那么f(c) += 1。(没有找到不同元素，只需要把相同元素累计起来)
# 如果当前元素A[i] != c，那么f(c) -= 1。 (相当于删除1个c)，不对A[i]做任何处理(相当于删除A[i])

# 如果遍历结束之后，f(c)不为0，那么元素c即为寻找的元素。
# 上述算法的时间复杂度为O(n)，而由于并不需要真的删除数组元素，我们也并不需要额外的空间来保存原始数组，空间复杂度为O(1)。
